---
title: Arc<str> vs String, is Arc<str> really faster?
description: Analysis of Arc<str> vs String cloning performance in contentended scenarios.
pubDate: 'Dec 30 2023'
---
import graph from './arc_str_vs_string_graph.png';

TODO: ADD A SECTION HERE ABOUT THE INSPIRATION FOR THIS
THE VIDEO ABOUT ARC STR AND PRIMAGENS REACTION

The short (and possibly incorrect) answer is probably yes,
but that's not what you're here for.

## How does this even work?
TODO: EXPLAIN DSTs

## What does "faster" even mean?
In this case we're talking about cloning performance, aka how long
it takes to call the `.clone()` function on the element.

In the case of `String` this means allocating a new string and
then `memcopy`ing the data over.
`Arc<str>` by comparison simply increments the strong reference counter.

## Expectations
You would expect a single increment to always be faster than a call
to `malloc` and then `memcopy`, since, that's supposedly a complex
call which should take much longer than the increment operation.

## Methodology
TODO: FINISH THIS
TODO: REMEMBER TO LINK BENCHMARK PROGRAM
TODO: REMEMBER TO ADD SYSTEM SPECS

## Results
<img src={graph.src} width="650" alt="Chart showing performance differences between Arc<str>- and String-cloning" />
As you can see, our expectations are only representative of reality, when a single
thread accesses the `Arc<str>`. As soon as multiple threads are contending
for the `Arc<str>`, we start having issues and the performance of `String`
surpasses the performance of `Arc<str>` significantly. Now the question
remains, why does it have much greater performance?

## Explanation
This information is based on `Jemallocator`, but may also be applicable to other multithreaded allocators.

Firstly, all references of `Arc<str>` refer to the same instance, which
means all clone operations operate on the same atomic integer, which as
I alluded to before causes significant lock contention. `String` by contrast
calls `Jemalloc`s `malloc` implementation, which uses thread-local arenas to
get around this.

What's still unexplained is why `String` gets *slower* when we *don't* drop
the `String` after each use. This is simply explained by how `Jemalloc` allocates
memory. As you might already know allocating memory from the kernel on Linux
happens using the `mmap` syscall, which takes time. Therefore the allocator
attempts to call `mmap` as little as possible, by putting multiple allocations
into a single `mmap`ed "bucket". Therefore, if we constantly `malloc` then
immediately `free` the allocated memory, we are always using just
a single **thread-local** "bucket" for our allocation, no syscalls involved!
If we instead leak the memory, the allocator now has to constantly allocate
new memory using `mmap`, which, while probably amortized using bigger allocations,
still takes quite a bit of time.

This can be seen in the following comparison using the `tikv_jemalloc_ctl::stats::mapped` API to get the amount
of mapped memory:

Mapped Memory when dropping:
```
Running on 8 threads concurrently.
Using strings of size 64.
Running 16777216 samples.
Dropping cloned elements.
Current mapped amount: 8.5 MB
Current mapped amount: 8.5 MB
[...]
Current mapped amount: 8.5 MB
Current mapped amount: 8.5 MB
Took 3125ms to perform 16777216 clone operations on alloc::sync::Arc<str>.
Current mapped amount: 8.6 MB
Current mapped amount: 29.8 MB
Current mapped amount: 29.8 MB
[...]
Current mapped amount: 29.8 MB
Current mapped amount: 29.8 MB
Took 308ms to perform 16777216 clone operations on alloc::string::String.
```

Mapped memory when not dropping:
```
Running on 8 threads concurrently.
Using strings of size 64.
Running 16777216 samples.
Not dropping cloned elements.
Current mapped amount: 8.5 MB
Current mapped amount: 8.5 MB
[...]
Current mapped amount: 8.5 MB
Current mapped amount: 8.5 MB
Took 1952ms to perform 16777216 clone operations on alloc::sync::Arc<str>.
Current mapped amount: 53.7 MB
Current mapped amount: 156.6 MB
Current mapped amount: 268.9 MB
Current mapped amount: 385.7 MB
Current mapped amount: 501.3 MB
Current mapped amount: 630.1 MB
[...]
Current mapped amount: 9.3 GB
Current mapped amount: 9.4 GB
Current mapped amount: 9.5 GB
Current mapped amount: 9.6 GB
Current mapped amount: 9.7 GB
Current mapped amount: 9.8 GB
Current mapped amount: 9.9 GB
Took 968ms to perform 16777216 clone operations on alloc::string::String.
```

As you can see, the amount of mapped memory when using `Arc<str>` is obviously
static, since it doesn't allocate memory, but the `String` allocates new memory
on each clone and if we don't drop the cloned `String`, we create a memory leak,
which means the allocator has to constantly request more memory using the `mmap`
syscall.

Verifying this can be done using the `strace` command:
```
# TOTAL_THREAD_COUNT=8 SHOULD_DROP=yes strace ./target/release/arc_str_perf &| grep "MAP_ANONYMOUS" | wc -l
18
# TOTAL_THREAD_COUNT=8 SHOULD_DROP=no strace ./target/release/arc_str_perf &| grep "MAP_ANONYMOUS" | wc -l
46
```

## Conclusion
